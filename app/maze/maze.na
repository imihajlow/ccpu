#include "maze.h"
#include <string.h>
#include <random.h>
#include <vga.h>

#define CHAR_EMPTY '.'
#define CHAR_WALL '#'
#define CHAR_PLAYER '@'
#define CHAR_KEY 'J'
#define CHAR_DOOR '>'

import s8 trap();

#define MAZE_ARRAY_SIZE (MAZE_MAX_SIDE * MAZE_MAX_SIDE)

u8 maze_data[MAZE_ARRAY_SIZE];
u8 width;
u8 height;

export u8 maze_init(u8 w, u8 h)
{
    memset((u8*)maze_data, MAZE_WALL, (u16)w * (u16)h);
    width = w;
    height = h;
}

#define DFS_STACK_SIZE 4096

export u8 maze_dfs(u8 ux, u8 uy)
{
    u8 directions[4];
    u8 i;
    u16 index;
    s8 stack[DFS_STACK_SIZE];
    s8 *sp = (s8*)stack;

    *sp = (s8)ux;
    *(sp + 1) = (s8)uy;
    *(sp + 2) = (s8)ux;
    *(sp + 3) = (s8)uy;
    sp += 4;
    directions[0] = NORTH;
    directions[1] = EAST;
    directions[2] = SOUTH;
    directions[3] = WEST;

    while (sp != (s8*)stack)
    {
        sp += -4;
        s8 x = *sp;
        s8 y = *(sp + 1);
        s8 xl = *(sp + 2);
        s8 yl = *(sp + 3);

        index = (u16)x + (u16)y * (u16)width;
        if (maze_data[index])
            continue;
        maze_data[index] = MAZE_PASSAGE;
        index = (((u16)xl + (u16)yl * (u16)width) + index) >> (u8)1; // wall between squares
        maze_data[index] = MAZE_PASSAGE;
        xl = x;
        yl = y;

        i = (u8)4;
        while (i > (u8)1) {
            u16 n;
            u8 t;
            n = random((u16)i);
            t = directions[(s16)i - 1];
            directions[(s16)i - 1] = directions[n];
            directions[n] = t;
            i -= (u8)1;
        }

        i = (u8)0;
        while (i < (u8)4) {
            s8 xn;
            s8 yn;
            u8 dir = directions[(s16)i];

            xn = x;
            yn = y;
            if (dir == NORTH) {
                yn -= (s8)2;
            } else if (dir == EAST) {
                xn += (s8)2;
            } else if (dir == SOUTH) {
                yn += (s8)2;
            } else {
                xn -= (s8)2;
            }
            if (xn >= (s8)0 && yn >= (s8)0 && xn < (s8)width && yn < (s8)height) {
                *sp = xn;
                *(sp + 1) = yn;
                *(sp + 2) = x;
                *(sp + 3) = y;
                sp += 4;
            }
            i += (u8)1;
        }
    }
}

export u8 maze_get(s8 x, s8 y)
{
    if (x >= (s8)0 && x < (s8)width && y >= (s8)0 && y < (s8)height) {
        return maze_data[(u16)x + (u16)y * (u16)width];
    } else {
        return MAZE_WALL;
    }
}

export u8 maze_set(u8 x, u8 y, u8 v)
{
    maze_data[(u16)x + (u16)y * (u16)width] = v;
}

export u8 maze_show_all(u8 player_x, u8 player_y)
{
    u8 left = (VGA_COLS - width) >> 1u8;
    u8 top = (VGA_ROWS - width) >> 1u8;

    u8* screen_offset = (u8*)vga_char_seg + VGA_OFFSET(left, top);
    u16 maze_offset = 0u16;
    for (u8 y = 0u8; y < height; y += 1u8) {
        for (u8 x = 0u8; x < width; x += 1u8) {
            u8 c = CHAR_EMPTY;
            u8 e = maze_data[maze_offset];
            if (e == MAZE_WALL) {
                c = CHAR_WALL;
            } else if (e == MAZE_KEY) {
                c = CHAR_KEY;
            } else if (e == MAZE_EXIT) {
                c = CHAR_DOOR;
            }
            vga_set(screen_offset, c);

            maze_offset += 1u16;
            screen_offset += 1u8;
        }
        screen_offset += 128u8;
        screen_offset -= (s16)width;
    }
    vga_set((u8*)vga_char_seg + VGA_OFFSET(left + player_x, top + player_y), CHAR_PLAYER);
}

export u8 maze_show_player_move(u8 from_x, u8 from_y, u8 to_x, u8 to_y)
{
    u8 left = (VGA_COLS - width) >> 1u8;
    u8 top = (VGA_ROWS - width) >> 1u8;

    vga_set((u8*)vga_char_seg + VGA_OFFSET(left + to_x, top + to_y), CHAR_PLAYER);
    vga_set((u8*)vga_char_seg + VGA_OFFSET(left + from_x, top + from_y), CHAR_EMPTY);
}
