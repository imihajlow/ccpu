#include <vga.h>
#include "z80run.h"

#define PASS_COLOR COLOR(COLOR_WHITE, COLOR_GREEN)
#define FAIL_COLOR COLOR(COLOR_WHITE, COLOR_RED)

#define TEST_COUNT 20u8

u8 test_number;


u8 get_test_number_row(u8 n) {
    return n >> 4u8;
}

u8 get_test_number_col(u8 n) {
    return (n & 0xfu8) * 4u8;
}

u8 ok() {
    u8 r = get_test_number_row(test_number);
    u8 c = get_test_number_col(test_number);
    u8 *p = (u8*)vga_color_seg + VGA_OFFSET(c, r);
    *p = PASS_COLOR;
    p += 1u8;
    *p = PASS_COLOR;
    p += 1u8;
    *p = PASS_COLOR;
    p += 1u8;
    *p = PASS_COLOR;
    p += 1u8;
}

u8 fail() {
    u8 r = get_test_number_row(test_number);
    u8 c = get_test_number_col(test_number);
    u8 *p = (u8*)vga_color_seg + VGA_OFFSET(c, r);
    *p = FAIL_COLOR;
    p += 1u8;
    *p = FAIL_COLOR;
    p += 1u8;
    *p = FAIL_COLOR;
    p += 1u8;
    *p = FAIL_COLOR;
    p += 1u8;
}

u8 draw_test_numbers() {
    u8 i = 0u8;
    for (; i != TEST_COUNT; i += 1u8) {
        u8 r = get_test_number_row(i);
        u8 c = get_test_number_col(i);
        vga_put_decimal_u16(c, r, (u16)i);
    }
}
#define FLAG_C  1u8
#define FLAG_N  2u8
#define FLAG_P  4u8
#define FLAG_H  0x10u8
#define FLAG_Z  0x40u8
#define FLAG_S  0x80u8

#define HALT 0x76u8
import u16 z80_hl;
import u16 z80_de;
import u16 z80_bc;
import u16 z80_ix;
import u16 z80_iy;

import u8 z80_f;
import u8 z80_a;
import u8 z80_c;
import u8 z80_b;
import u8 z80_e;
import u8 z80_d;
import u8 z80_l;
import u8 z80_h;

#define ASSERT(b) if (!(b)) { fail(); return; }

u8 test_copy_reg() {
    test_number = 0u8;
    z80_a = 0xccu8;
    z80_b = 0xddu8;
    z80run({0x47u8, HALT}); // ld b, a
    ASSERT(z80_b == 0xccu8);

    z80_h = 0x5au8;
    z80run({0x7cu8, HALT}); // ld a, h
    ASSERT(z80_a == 0x5au8);
    ok();
}

u8 test_copy_r_indir() {
    test_number = 1u8;
    u8 var = 0x89u8;
    z80_hl = (u16)&var;
    z80_e = 0x00u8;
    z80run({0x5eu8, HALT}); // ld e, (hl)
    ASSERT(z80_e == 0x89u8);

    u32 var32 = 0x12345678u32;
    z80_c = 0x00u8;
    z80_d = 0x00u8;
    z80_ix = (u16)&var32 - 50u16;
    z80_iy = (u16)&var32 + 15u16;
    z80run({
        // ld c, (ix + 50)
        0xddu8, 0x4eu8, 50u8,
        // ld e, c
        0x59u8,
        // ld d, (iy - 14)
        0xfdu8, 0x56u8, (u8)-14s8,
        HALT
    });
    ASSERT(z80_c == 0x78u8);
    ASSERT(z80_e == 0x78u8);
    ASSERT(z80_d == 0x56u8);
    ok();
}

u8 test_store_indir_r() {
    test_number = 2u8;
    u8 dest1 = 0x00u8;
    u16 dest2 = 0x0000u16;
    z80_hl = (u16)&dest1;
    z80_c = 0x24u8;
    z80_d = 0xf9u8;
    z80_a = 0x42u8;
    z80_ix = (u16)&dest2 - 18u16;
    z80_iy = (u16)&dest2 + 100u16;
    z80run({
        // ld (hl), c
        0x71u8,
        // ld (ix + 19), d
        0xddu8, 0x72u8, 19u8,
        // ld (iy - 100), a
        0xfdu8, 0x77u8, (u8)-100s8,
        HALT
    });
    ASSERT(dest1 == 0x24u8);
    ASSERT(dest2 == 0xf942u16);
    z80_bc = (u16)&dest1;
    z80_de = (u16)&dest2 + 1u16;
    z80_a = 0xbcu8;
    z80run({
        // ld (bc), a
        0x02u8,
        HALT
    });
    ASSERT(dest1 == 0xbcu8);
    z80_a = 0xdeu8;
    z80run({
        // ld (de), a
        0x12u8,
        HALT
    });
    ASSERT(dest2 == 0xde42u16);
    ok();
}

u8 test_store_indir_imm() {
    test_number = 3u8;
    u8 dest1 = 0u8;
    u16 dest2 = 0u16;
    z80_hl = (u16)&dest1;
    z80_ix = (u16)&dest2 + 18u16;
    z80_iy = (u16)&dest2 - 100u16;
    z80run({
        // ld (hl), 0x33
        0x36u8, 0x33u8,
        // ld (ix - 18), 0x44
        0xddu8, 0x36u8, (u8)-18s8, 0x44u8,
        // ld (iy + 101), 0x55
        0xfdu8, 0x36u8, 101u8, 0x55u8,
        HALT
    });
    ASSERT(dest1 == 0x33u8);
    ASSERT(dest2 == 0x5544u16);
    ok();
}

u8 test_store_reg_imm() {
    test_number = 4u8;
    z80_a = 0u8;
    z80_b = 0u8;
    z80_c = 0u8;
    z80_d = 0u8;
    z80_e = 0u8;
    z80_h = 0u8;
    z80_l = 0u8;
    z80run({
        // ld a, 0x11
        0x3eu8, 0x11u8,
        // ld b, 0x22
        0x06u8, 0x22u8,
        // ld c, 0x33
        0x0eu8, 0x33u8,
        // ld d, 0x44
        0x16u8, 0x44u8,
        // ld e, 0x55
        0x1eu8, 0x55u8,
        // ld h, 0x66
        0x26u8, 0x66u8,
        // ld l, 0x77
        0x2eu8, 0x77u8,
        HALT
    });
    ASSERT(z80_a == 0x11u8);
    ASSERT(z80_b == 0x22u8);
    ASSERT(z80_c == 0x33u8);
    ASSERT(z80_d == 0x44u8);
    ASSERT(z80_e == 0x55u8);
    ASSERT(z80_h == 0x66u8);
    ASSERT(z80_l == 0x77u8);
    ok();
}

struct LdAIndir {
    u8 opcode;
    u8 *src;
    u8 halt;
};

u8 test_ld_a_indir_imm16() {
    test_number = 5u8;
    u8 src = 0x67u8;
    z80_a = 0u8;
    struct LdAIndir code;
    code.opcode = 0x3au8; // ld a, (imm16)
    code.src = &src;
    code.halt = HALT;
    z80run((u8*)&code);
    ASSERT(z80_a == 0x67u8);

    z80_a = 0x12u8;
    code.opcode = 0x32u8; // ld (imm16), a
    z80run((u8*)&code);
    ASSERT(src == 0x12u8);
    ok();
}

u8 test_ld_a_indir_bcde() {
    test_number = 6u8;
    u16 src = 0x1234u16;
    z80_a = 0u8;
    z80_bc = (u16)&src;
    z80_de = (u16)&src + 1u16;
    z80run({
        // ld a, (bc)
        0x0au8,
        HALT
    });
    ASSERT(z80_a == 0x34u8);
    z80run({
        // ld a, (de)
        0x1au8,
        HALT
    });
    ASSERT(z80_a == 0x12u8);
    ok();
}

u8 test_arithm8_add() {
    test_number = 7u8;
    z80_f = 0u8;
    z80_a = 25u8;
    z80_c = 78u8;
    z80run({
        // add a, c
        0x81u8,
        HALT
    });
    ASSERT(z80_a == 25u8 + 78u8);
    ASSERT(z80_f == 0u8);
    z80_a = 127u8;
    z80_d = 1u8;
    z80run({
        // add a, d
        0x82u8,
        HALT
    });
    ASSERT(z80_a == 128u8);
    ASSERT(z80_f == (FLAG_S | FLAG_P));
    z80_a = 255u8;
    z80_e = 1u8;
    z80run({
        // add a, e
        0x83u8,
        HALT
    });
    ASSERT(z80_a == 0u8);
    ASSERT(z80_f == (FLAG_C | FLAG_Z));
    z80_a = 253u8;
    z80_h = 255u8;
    z80run({
        // add a, h
        0x84u8,
        HALT
    });
    ASSERT(z80_a == 252u8);
    ASSERT(z80_f == (FLAG_C | FLAG_S));
    z80_a = 129u8;
    z80_l = 130u8;
    z80run({
        // add a, l
        0x85u8,
        HALT
    });
    ASSERT(z80_a == 3u8);
    ASSERT(z80_f == (FLAG_C | FLAG_P));
    ok();
}

u8 test_arithm8_ops() {
    test_number = 8u8;
    z80_f = FLAG_C;
    z80_a = 5u8;
    z80_b = 10u8;
    z80run({
        // adc a, b
        0x88u8,
        HALT
    });
    ASSERT(z80_a == 16u8);
    ASSERT(z80_f == 0u8);

    z80_a = 5u8;
    z80_c = 10u8;
    z80run({
        // sub a, c
        0x91u8,
        HALT
    });
    ASSERT(z80_a == (u8)-5s8);
    ASSERT(z80_f == (FLAG_C | FLAG_S | FLAG_N));

    z80_a = 60u8;
    z80_d = 20u8;
    z80run({
        // sbc a, d
        0x9au8,
        HALT
    });
    ASSERT(z80_a == 39u8);
    ASSERT(z80_f == (FLAG_N));

    z80_a = 0xf0u8;
    z80_e = 0xa5u8;
    z80run({
        // and a, e
        0xa3u8,
        HALT
    });
    ASSERT(z80_a == 0xa0u8);
    ASSERT(z80_f == (FLAG_S | FLAG_H));

    z80_a = 0xa0u8;
    z80_h = 0x03u8;
    z80run({
        // or a, h
        0xb4u8,
        HALT
    });
    ASSERT(z80_a == 0xa3u8);
    ASSERT(z80_f == FLAG_S);

    z80_a = 0x0fu8;
    z80_l = 0xa5u8;
    z80run({
        // xor a, l
        0xadu8,
        HALT
    });
    ASSERT(z80_a == 0xaau8);
    ASSERT(z80_f == (FLAG_S));

    z80_a = 5u8;
    z80_c = 10u8;
    z80run({
        // cp a, c
        0xb9u8,
        HALT
    });
    ASSERT(z80_a == 5u8);
    ASSERT(z80_f == (FLAG_C | FLAG_S | FLAG_N));
    ok();
}

u8 test_arithm8_imm_and_indir() {
    test_number = 9u8;
    z80_a = 140u8;
    z80_f = 0u8;
    z80run({
        // sbc a, 20
        0xdeu8, 20u8,
        HALT
    });
    ASSERT(z80_a == 120u8);
    ASSERT(z80_f == (FLAG_P | FLAG_N));

    u32 src = 0x12345678u32;
    z80_a = 0xd0u8;
    z80_hl = (u16)&src;
    z80run({
        // and a, (hl)
        0xa6u8,
        HALT
    });
    ASSERT(z80_a == (0x78u8 & 0xd0u8));
    ASSERT(z80_f == FLAG_H);

    z80_a = 0x55u8;
    z80_ix = (u16)&src + 77u16;
    z80run({
        // xor a, (ix - 76)
        0xddu8, 0xaeu8, (u8)-76s8,
        HALT
    });
    ASSERT(z80_a == (0x56u8 ^ 0x55u8));
    ASSERT(z80_f == 0u8);

    z80_a = 0xa0u8;
    z80_iy = (u16)&src - 42u16;
    z80run({
        // add a, (iy + 44)
        0xfdu8, 0x86u8, 44u8,
        HALT
    });
    ASSERT(z80_a == (0x34u8 + 0xa0u8));
    ASSERT(z80_f == (FLAG_S));

    ok();
}

export u8 main() {
    vga_clear(COLOR(COLOR_GRAY, COLOR_BLACK));
    test_number = 0u8;
    z80_a = 5u8;
    draw_test_numbers();
    test_copy_reg();
    test_copy_r_indir();
    test_store_indir_r();
    test_store_indir_imm();
    test_store_reg_imm();
    test_ld_a_indir_imm16();
    test_ld_a_indir_bcde();
    test_arithm8_add();
    test_arithm8_ops();
    test_arithm8_imm_and_indir();
}
