#include "fat.h"
#include <card.h>
#include <string.h>

#define MAX_FILE_DESC 4u8

struct Partition {
    u8 boot; // 0x00
    u8 start_h; // 0x01
    u8 start_s; // 0x08
    u8 start_c; // 0x00
    u8 sys_id; // 0x06
    u8 end_h;  // 0x07
    u8 end_s; // 0x60
    u8 end_c; // 0xe4
    u32 rel_sector; // 0x00000027
    u32 n_sectors; // 0x0001e4d9
};

struct BPB {
        u8 jump[3];
        u8 oem_id[8];
        u16 bytes_per_sector; // 0x0200
    u8 sectors_per_cluster; // 0x04
    u16 n_reserved_sectors; // 0x0001
    u8 n_fats; // 0x02
    u16 n_dir_entries; // 0x0200
    u16 total_sectors; // 0x0000
        u8 media_descriptor_type; // 0xf8
    u16 sectors_per_fat; // 0x0079
        u16 sectors_per_track; // 0x0020
        u16 n_heads; // 0x0010
    u32 n_hidden_sectors; // 0x00000027
    u32 large_sectors; // 0x0001e4d9
};

struct FatInfo {
    u32 fat0_offset;
    u32 fat1_offset;
    u16 sectors_per_fat;
    u32 root_dir_offset;
    u8 log_sectors_per_cluster;
    u16 n_dir_entries;
    u32 data_offset;
};

struct FileDescriptor {
    u8 is_free;
    u16 last_cluster_len; // number of bytes in the last cluster in the chain
    u32 block_addr; // current block
    u8 block_in_cluster; // block index in current cluster
    u16 index_in_block; // read/write pointer in current block
    u16 next_cluster; // value from the FAT
    u16 cur_cluster; // index in the FAT
    struct FatDirEntry dir_entry;
    u32 dir_entry_block_addr; // absolute offset on disc
    u16 dir_entry_index_in_block; // offset inside the block
    u8 is_root; // for directory descriptors: if this is a root directory (a special case)
    u8 filler[11];
};

#define INVALID_BLOCK_ADDR 0xffffffffu32
u8 cache_block[CARD_BLOCK_SIZE];
u32 cache_block_addr;

struct FatInfo fat_info;
struct FileDescriptor file_desc[MAX_FILE_DESC];

export u8 fat_init() {
    for (u8 i = 0u8; i != MAX_FILE_DESC; i += 1u8) {
        file_desc[i].is_free = 1u8;
    }
    cache_block_addr = INVALID_BLOCK_ADDR;

    struct Partition partition;
    struct BPB bpb;
    u8 r = card_read_block(0u32, 446u16, sizeof(struct Partition), (u8*)&partition);
    if (r) {
        return FAT_ERROR_CARD;
    }

    u32 offset = partition.rel_sector << 9u8;
    r = card_read_block(partition.rel_sector << 9u8, 0u16, sizeof(struct BPB), (u8*)&bpb);
    if (r) {
        return FAT_ERROR_CARD;
    }

    if (bpb.bytes_per_sector != 512u16) {
        return FAT_ERROR_UNSUPPORTED_SECTOR_SIZE;
    }
    offset = bpb.n_hidden_sectors << 9u8;
    offset += (u32)bpb.n_reserved_sectors << 9u8;
    fat_info.fat0_offset = offset; // 5000
    offset += (u32)bpb.sectors_per_fat << 9u8;
    if (bpb.n_fats == 2u8) {
        fat_info.fat1_offset = offset;
        offset += (u32)bpb.sectors_per_fat << 9u8;
    } else if (bpb.n_fats > 2u8) {
        return FAT_ERROR_TOO_MANY_FATS;
    }
    fat_info.root_dir_offset = offset; // 23400
    fat_info.sectors_per_fat = bpb.sectors_per_fat;
    fat_info.log_sectors_per_cluster = 0u8;
    while (bpb.sectors_per_cluster > 1u8) {
        fat_info.log_sectors_per_cluster += 1u8;
        bpb.sectors_per_cluster >>= 1u8;
    }
    fat_info.n_dir_entries = bpb.n_dir_entries;
    offset += (u32)((fat_info.n_dir_entries + 15u16) >> 4u8) << 9u8; // 27400
    fat_info.data_offset = offset;

    return 0u8;
}

export u8 fat_open_dir(struct FatDirEntry *de) {
    u8 fd;
    if ((u16)de != 0u16 && de->cluster_lo == 0u16) {
        de = (struct FatDirEntry *)0u8;
    }
    if ((u16)de != 0u16) {
        fd = fat_open_file(de);
        if (fd == FAT_BAD_DESC) {
            return FAT_BAD_DESC;
        }

        file_desc[fd].is_root = 0u8;
    } else {
        struct FileDescriptor *dsc = (struct FileDescriptor *)file_desc;
        for (fd = 0u8; fd != MAX_FILE_DESC && !dsc->is_free; fd += 1u8) {
            dsc += 1u8;
        }
        if (fd == MAX_FILE_DESC) {
            return FAT_BAD_DESC;
        }
        dsc->is_free = 0u8;
        dsc->is_root = 1u8;

        dsc->block_addr = fat_info.root_dir_offset;
        dsc->block_in_cluster = 0u8;
        dsc->index_in_block = 0u16;
    }
    return fd;
}

u8 cache(u32 block_addr) {
    if (cache_block_addr == block_addr) {
        return 0u8;
    }
    cache_block_addr = block_addr;
    u8 r = card_read_block(block_addr, 0u16, CARD_BLOCK_SIZE, (u8*)cache_block);
    if (r) {
        cache_block_addr = INVALID_BLOCK_ADDR;
    }
    return r;
}

export u8 to_fat_name(u8 *dst, u8 *src) {
    u8 i, c;
    memset(dst, ' ', 11u16); // name + extension, all spaces
    for (i = 0u8; i < 8u8; i += 1u8) {
        c = *src;
        if (!c || c == '.') {
            break;
        }
        dst[i] = c;
        src += 1u8;
    }
    if (c == '.') {
        src += 1u8;
        c = *src;
    } else if (c) {
        while (c && c != '.') {
            src += 1u8;
            c = *src;
        }
    }
    for (i = 8u8; c && i < 11u8; i += 1u8) {
        dst[i] = c;
        src += 1u8;
        c = *src;
    }
}

export u8 from_fat_name(u8 *dst, u8 *src) {
    u8 i, c;
    for (i = 0u8; i != 8u8; i += 1u8) {
        c = src[i];
        if (c == ' ') {
            break;
        }
        *dst = c;
        dst += 1u8;
    }
    if (src[8] != ' ') {
        *dst = '.';
        dst += 1u8;
        for (i = 8u8; i != 11u8; i += 1u8) {
            c = src[i];
            if (c == ' ') {
                break;
            }
            *dst = c;
            dst += 1u8;
        }
    }
    *dst = 0u8;
}

export u8 fat_get_next_dir_entry(u8 desc, struct FatDirEntry *dst) {

export u8 fat_get_next_dir_entry(u8 desc, struct FatDirEntry *dst, u8 attr_skip_mask) {
    struct FileDescriptor *pfd = (struct FileDescriptor *)file_desc + desc;
    if (pfd->is_free) {
        return 0u8;
    }

    u8 r;
    while (1u8) {
        r = cache(pfd->block_addr);
        if (r) {
            return 0u8;
        }
        memcpy((u8*)dst, (u8*)cache_block + pfd->index_in_block, sizeof(struct FatDirEntry));
        pfd->index_in_block += sizeof(struct FatDirEntry);

        if (pfd->index_in_block == CARD_BLOCK_SIZE) {
            pfd->index_in_block = 0u16;
            if (pfd->is_root) {
                pfd->block_addr += (u32)CARD_BLOCK_SIZE;
            } else {
                pfd->block_in_cluster += 1u8;
                if (pfd->block_in_cluster >> fat_info.log_sectors_per_cluster) {
                    pfd->block_addr = fat_info.data_offset;
                    pfd->block_addr += (u32)(pfd->next_cluster - 2u16) << (fat_info.log_sectors_per_cluster + 9u8);
                    pfd->cur_cluster = pfd->next_cluster;
                    pfd->next_cluster = read_fat_entry(pfd->cur_cluster);
                    pfd->block_in_cluster = 0u8;
                } else {
                    pfd->block_addr += (u32)CARD_BLOCK_SIZE;
                }
            }
        }

        if (dst->filename[0] == 0u8) { // last entry
            return 0u8;
        }
        if (dst->filename[0] == 0xe5u8) { // empty entry
            continue;
        }
        if (dst->attrs == 0x0fu8) { // long filename
            continue;
        }
        if (dst->attrs & attr_skip_mask) {
            continue;
        }
        return 1u8;
    }
}

u16 read_fat_entry(u16 index) {
    u16 sector_offset = (u16)(u8)(index) << 1u8;
    u16 sector_index = index >> 8u8;
    u16 result;
    u8 r;
    if (sector_index != 0u16) {
        u32 disk_offset;
        disk_offset = fat_info.fat0_offset;
        disk_offset += (u32)sector_index << 9u8;
        r = card_read_block(disk_offset, sector_offset, sizeof(u16), (u8*)&result);
    } else {
        r = card_read_block(fat_info.fat0_offset, sector_offset, sizeof(u16), (u8*)&result);
    }
    if (r) {
        return 0u16;
    } else {
        return result;
    }
}

export u8 fat_open_file(struct FatDirEntry *dsc) {
    for (u8 fd = 0u8; fd != MAX_FILE_DESC; fd += 1u8) {
        if (file_desc[fd].is_free) {
            break;
        }
    }
    if (fd == MAX_FILE_DESC) {
        return FAT_BAD_DESC;
    }

    struct FileDescriptor *pfd = (struct FileDescriptor *)file_desc + fd;
    pfd->is_free = 0u8;
    u8 cluster_bits = 9u8 + fat_info.log_sectors_per_cluster;
    u16 cluster_mask = ~(0xffffu16 << cluster_bits);
    pfd->last_cluster_len = (u16)dsc->size & cluster_mask;

    pfd->block_addr = fat_info.data_offset;
    pfd->block_addr += (u32)(dsc->cluster_lo - 2u16) << (fat_info.log_sectors_per_cluster + 9u8);
    pfd->block_in_cluster = 0u8;
    pfd->index_in_block = 0u16;
    pfd->next_cluster = read_fat_entry(dsc->cluster_lo);
    pfd->cur_cluster = dsc->cluster_lo;
    return fd;
}

export u16 fat_read(u8 fd, u8 *dst, u16 len) {
    struct FileDescriptor *pfd = (struct FileDescriptor *)file_desc + fd;
    if (pfd->is_free) {
        return 0u16;
    }
    u16 result = 0u16;
    u8 r;
    while (len != 0u16) {
        u16 to_read;
        if (pfd->next_cluster >= 0xFFF8u16) {
            // last cluster
            u16 remainder = pfd->last_cluster_len - ((u16)pfd->block_in_cluster << 9u8);
            if (remainder <= CARD_BLOCK_SIZE) {
                // last block
                to_read = remainder - pfd->index_in_block;
            } else {
                to_read = CARD_BLOCK_SIZE - pfd->index_in_block;
            }
        } else {
            to_read = CARD_BLOCK_SIZE - pfd->index_in_block;
        }
        if (to_read > len) {
            to_read = len;
        }
        if (to_read == 0u16) {
            return result;
        }
        r = cache(pfd->block_addr);
        if (r) {
            return result | 0x8000u16;
        }
        memcpy(dst, (u8*)cache_block + pfd->index_in_block, to_read);
        len -= to_read;
        dst += to_read;
        result += to_read;
        pfd->index_in_block += to_read;
        if (pfd->index_in_block == CARD_BLOCK_SIZE) {
            pfd->block_in_cluster += 1u8;
            pfd->index_in_block = 0u16;
            if (pfd->block_in_cluster >> fat_info.log_sectors_per_cluster) {
                // next cluster
                pfd->block_addr = fat_info.data_offset;
                pfd->block_addr += (u32)(pfd->next_cluster - 2u16) << (fat_info.log_sectors_per_cluster + 9u8);
                pfd->cur_cluster = pfd->next_cluster;
                pfd->next_cluster = read_fat_entry(pfd->cur_cluster);
                pfd->block_in_cluster = 0u8;
            } else {
                // next block in cluster
                pfd->block_addr += (u32)CARD_BLOCK_SIZE;
            }
        }
    }
    return result;
}

export u8 fat_close_file(u8 fd) {

export u8 fat_close(u8 fd) {
    file_desc[fd].is_free = 1u8;
}
