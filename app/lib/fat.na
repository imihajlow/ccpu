#include "fat.h"
#include <card.h>
#include <string.h>
#include <log.h>

#define FAT_MIN_LAST_CLUSTER 0xFFF8u16
#define MAX_FILE_DESC 4u8

struct Partition {
    u8 boot; // 0x00
    u8 start_h; // 0x01
    u8 start_s; // 0x08
    u8 start_c; // 0x00
    u8 sys_id; // 0x06
    u8 end_h;  // 0x07
    u8 end_s; // 0x60
    u8 end_c; // 0xe4
    u32 rel_sector; // 0x00000027
    u32 n_sectors; // 0x0001e4d9
};

struct BPB {
        u8 jump[3];
        u8 oem_id[8];
        u16 bytes_per_sector; // 0x0200
    u8 sectors_per_cluster; // 0x04
    u16 n_reserved_sectors; // 0x0001
    u8 n_fats; // 0x02
    u16 n_dir_entries; // 0x0200
    u16 total_sectors; // 0x0000
        u8 media_descriptor_type; // 0xf8
    u16 sectors_per_fat; // 0x0079
        u16 sectors_per_track; // 0x0020
        u16 n_heads; // 0x0010
    u32 n_hidden_sectors; // 0x00000027
    u32 large_sectors; // 0x0001e4d9
};

struct FatInfo {
    u32 fat0_offset;
    u32 fat1_offset;
    u16 sectors_per_fat;
    u32 root_dir_block;
    u8 log_sectors_per_cluster;
    u8 sectors_per_cluster;
    u16 n_dir_entries;
    u32 data_offset;
    u16 n_clusters;
};

struct FileDescriptor {
    u8 is_free;
    u16 last_cluster_len; // number of bytes in the last cluster in the chain
    u32 block_addr; // current block
    u8 block_in_cluster; // block index in current cluster
    u16 index_in_block; // read/write pointer in current block
    u16 next_cluster; // value from the FAT
    u16 cur_cluster; // index in the FAT
    struct FatDirEntry dir_entry;
    u32 dir_entry_block_addr; // block index on disc
    u16 dir_entry_index_in_block; // offset inside the block
    u8 is_root; // for directory descriptors: if this is a root directory (a special case)
    u8 dir_entry_modified; // need to write out the dir entry on file close
    u32 abs_offset; // absolute read/write pointer
    u8 filler[6];
};

#define INVALID_BLOCK_ADDR 0xffffffffu32
u8 cache_block[CARD_BLOCK_SIZE];
u32 cache_block_addr;
export u8 fat_last_error;

struct FatInfo fat_info;
struct FileDescriptor file_desc[MAX_FILE_DESC];

export u8 fat_init() {
    for (u8 i = 0u8; i != MAX_FILE_DESC; i += 1u8) {
        file_desc[i].is_free = 1u8;
    }
    cache_block_addr = INVALID_BLOCK_ADDR;

    struct Partition partition;
    struct BPB bpb;
    u8 r = cache(0u32);
    if (!r) {
        return 0u8;
    }
    memcpy((u8*)&partition, (u8*)cache_block + 446, sizeof(struct Partition));

    u32 offset = partition.rel_sector;
    r = cache(offset);
    if (!r) {
        return 0u8;
    }
    memcpy((u8*)&bpb, (u8*)cache_block, sizeof(struct BPB));

    if (bpb.bytes_per_sector != 512u16) {
        fat_last_error = FAT_ERROR_UNSUPPORTED_SECTOR_SIZE;
        return 0u8;
    }
    offset = bpb.n_hidden_sectors;
    offset += (u32)bpb.n_reserved_sectors;
    fat_info.fat0_offset = offset; // 5000
    offset += (u32)bpb.sectors_per_fat;
    if (bpb.n_fats == 2u8) {
        fat_info.fat1_offset = offset;
        offset += (u32)bpb.sectors_per_fat;
    } else if (bpb.n_fats > 2u8) {
        fat_last_error = FAT_ERROR_TOO_MANY_FATS;
        return 0u8;
    }
    fat_info.root_dir_block = offset; // 23400
    fat_info.sectors_per_fat = bpb.sectors_per_fat;
    fat_info.sectors_per_cluster = bpb.sectors_per_cluster;
    fat_info.log_sectors_per_cluster = 0u8;
    while (bpb.sectors_per_cluster > 1u8) {
        fat_info.log_sectors_per_cluster += 1u8;
        bpb.sectors_per_cluster >>= 1u8;
    }
    fat_info.n_dir_entries = bpb.n_dir_entries;
    offset += (u32)((fat_info.n_dir_entries + 15u16) >> 4u8); // 27400
    fat_info.data_offset = offset;

    u32 data_sectors;
    if (bpb.total_sectors == 0u16) {
        data_sectors = bpb.large_sectors;
    } else {
        data_sectors = (u32)bpb.total_sectors;
    }
    data_sectors -= offset;
    u32 n_clusters = data_sectors >> fat_info.log_sectors_per_cluster;
    if (n_clusters < 4085u32) {
        // FAT12
        return FAT_ERROR_UNSUPPORTED_FAT_TYPE;
    } else if (n_clusters < 65525u32) {
        // FAT16
        fat_info.n_clusters = (u16)n_clusters;
    } else {
        // FAT32 or ExFAT
        return FAT_ERROR_UNSUPPORTED_FAT_TYPE;
    }

    return 1u8;
}

export u8 fat_open_dir(struct FatDirEntry *dir) {
    u8 fd, r;
    struct FileDescriptor *pfd = (struct FileDescriptor *)file_desc;
    for (fd = 0u8; fd != MAX_FILE_DESC && !pfd->is_free; fd += 1u8) {
        pfd += 1u8;
    }
    if (fd == MAX_FILE_DESC) {
        fat_last_error = FAT_ERROR_TOO_MANY_OPEN_FILES;
        return FAT_BAD_DESC;
    }
    pfd->is_free = 0u8;
    if ((u16)dir == 0u16 || dir->cluster_lo == 0u16) {
        // root dir
        init_root_dir(pfd);
    } else {
        memcpy((u8*)&pfd->dir_entry, (u8*)dir, sizeof(struct FatDirEntry));
        r = init_fd(pfd);
        if (!r) {
            pfd->is_free = 1u8;
            return FAT_BAD_DESC;
        }
    }
    return fd;
}

export u8 fat_change_dir(struct FatDirEntry *parent, u8 *name, struct FatDirEntry *dst) {
    if (name == (u8*)0) {
        dst->cluster_lo = 0u16;
        dst->attrs = FAT_FILE_ATTR_DIRECTORY;
        return 1u8;
    }
    struct FileDescriptor fd;
    u8 r = find_file(parent, name, &fd);

    if (r) {
        if (fd.dir_entry.attrs & FAT_FILE_ATTR_DIRECTORY) {
            memcpy((u8*)dst, (u8*)&fd.dir_entry, sizeof(struct FatDirEntry));
            return 1u8;
        } else {
            fat_last_error = FAT_ERROR_NOT_A_DIR;
        }
    }
    return 0u8;
}

u8 set_fat_error(u8 card_error) {
    if (card_error == CARD_ERROR_NO_CARD) {
        fat_last_error = FAT_ERROR_NO_CARD;
    } else if (card_error == CARD_ERROR_NOT_INITIALIZED) {
        fat_last_error = FAT_ERROR_CARD_REINSERTED;
    } else if (card_error == CARD_ERROR_OUT_OF_RANGE) {
        fat_last_error = FAT_ERROR_FS_BROKEN;
    } else {
        fat_last_error = FAT_ERROR_CARD;
    }
}

// returns bool
u8 cache(u32 block_addr) {
    if (cache_block_addr == block_addr) {
        return 1u8;
    }
    cache_block_addr = block_addr;
    u8 r = card_read_block(block_addr, (u8*)cache_block);
    if (r) {
        cache_block_addr = INVALID_BLOCK_ADDR;
        set_fat_error(r);
        return 0u8;
    }
    return 1u8;
}

// returns bool
u8 flush_cache() {
    if (cache_block_addr != INVALID_BLOCK_ADDR) {
        u8 r = card_write_block(cache_block_addr, (u8*)cache_block);
        if (r) {
            set_fat_error(r);
            return 0u8;
        }
    }
    return 1u8;
}

export u8 to_fat_name(u8 *dst, u8 *src) {
    u8 i, c;
    memset(dst, ' ', 11u16); // name + extension, all spaces
    if (*src == '.') {
        // just copy if it starts with a dot
        for (i = 0u8; i != 11u8; i += 1u8) {
            c = *src;
            if (!c) {
                return;
            }
            *dst = c;
            src += 1u8;
            dst += 1u8;
        }
        return;
    }
    for (i = 0u8; i != 8u8; i += 1u8) {
        c = *src;
        if (!c || c == '.') {
            break;
        }
        dst[i] = c;
        src += 1u8;
    }
    c = *src;
    if (c == '.') {
        src += 1u8;
        c = *src;
    } else if (c) {
        while (c && c != '.') {
            src += 1u8;
            c = *src;
        }
    }
    for (i = 8u8; c && i != 11u8; i += 1u8) {
        dst[i] = c;
        src += 1u8;
        c = *src;
    }
}

export u8 from_fat_name(u8 *dst, u8 *src) {
    u8 i, c;
    for (i = 0u8; i != 8u8; i += 1u8) {
        c = src[i];
        if (c == ' ') {
            break;
        }
        *dst = c;
        dst += 1u8;
    }
    if (src[8] != ' ') {
        *dst = '.';
        dst += 1u8;
        for (i = 8u8; i != 11u8; i += 1u8) {
            c = src[i];
            if (c == ' ') {
                break;
            }
            *dst = c;
            dst += 1u8;
        }
    }
    *dst = 0u8;
}

// Find file in dir by name and fill out dir_entry-related fields in file descriptor
// returns bool
u8 find_file(struct FatDirEntry *dir, u8 *name, struct FileDescriptor *pfd) {
    u8 r;

    u8 is_root = (u16)dir == 0u16 || dir->cluster_lo == 0u16;

    u8 fat_name[11];
    to_fat_name((u8*)fat_name, name);

    u32 block_addr;
    u16 cluster;
    if (is_root) {
        block_addr = fat_info.root_dir_block;
    } else {
        cluster = dir->cluster_lo;
    }
    u8 sector_in_block = 0u8;
    while (is_root || cluster < FAT_MIN_LAST_CLUSTER) {
        if (!is_root) {
            block_addr = fat_info.data_offset + ((u32)(cluster - 2u16) << fat_info.log_sectors_per_cluster);
            cluster = read_fat_entry(cluster);
            if (cluster == 0u16) {
                return 0u8;
            }
        }
        for (u8 block_in_cluster = 0u8; block_in_cluster != fat_info.sectors_per_cluster; block_in_cluster += 1u8) {
            log_u32(block_addr);
            r = cache(block_addr);
            if (!r) {
                return 0u8;
            }
            struct FatDirEntry *pentry = (struct FatDirEntry *)cache_block;
            for (u8 i = 0u8; i != (u8)(CARD_BLOCK_SIZE / sizeof(struct FatDirEntry)); i += 1u8) {
                if (pentry->filename[0] == 0u8) {
                    // last entry
                    fat_last_error = FAT_ERROR_NOT_FOUND;
                    return 0u8;
                }
                if (pentry->filename[0] != 0xe5u8) {
                    r = memcmp((u8*)pentry->filename, (u8*)fat_name, 11u16);
                    if (r == 0u8) {
                        memcpy((u8*)&pfd->dir_entry, (u8*)pentry, sizeof(struct FatDirEntry));
                        pfd->dir_entry_index_in_block = (u16)i << 5u8; // log sizeof(struct FatDirEntry)
                        pfd->dir_entry_block_addr = block_addr;
                        return 1u8;
                    }
                }
                pentry += 1u8;
            }
            block_addr += 1u32;
        }
    }
    fat_last_error = FAT_ERROR_NOT_FOUND;
    return 0u8;
}

export u8 fat_get_next_dir_entry(u8 desc, struct FatDirEntry *dst, u8 attr_skip_mask) {
    struct FileDescriptor *pfd = (struct FileDescriptor *)file_desc + desc;
    if (pfd->is_free) {
        fat_last_error = FAT_ERROR_BAD_DESCRIPTOR;
        return 0u8;
    }

    u8 r;
    fat_last_error = FAT_OK;
    while (1u8) {
        r = cache(pfd->block_addr);
        if (!r) {
            return 0u8;
        }
        memcpy((u8*)dst, (u8*)cache_block + pfd->index_in_block, sizeof(struct FatDirEntry));

        r = seek_advance(pfd, sizeof(struct FatDirEntry));

        if (!r) {
            return 0u8;
        }

        if (dst->filename[0] == 0u8) { // last entry
            return 0u8;
        }
        if (dst->filename[0] == 0xe5u8) { // empty entry
            continue;
        }
        if (dst->attrs == 0x0fu8) { // long filename
            continue;
        }
        if (dst->attrs & attr_skip_mask) {
            continue;
        }
        return 1u8;
    }
}

// returns 0 on error
u16 read_fat_entry(u16 index) {
    u16 entry_offset = (u16)(u8)(index);
    u16 sector_index = index >> 8u8;
    u8 r;
    u32 disk_offset;
    disk_offset = fat_info.fat0_offset;
    disk_offset += (u32)sector_index;
    r = cache(disk_offset);
    if (!r) {
        return 0u16;
    } else {
        return ((u16*)cache_block)[entry_offset];
    }
}

// returns bool
u8 write_fat_entry(u16 index, u16 value) {
    u16 entry_offset = (u16)(u8)(index);
    u16 sector_index = index >> 8u8;
    u8 r;
    u32 disk_offset;
    disk_offset = fat_info.fat0_offset;
    disk_offset += (u32)sector_index;
    r = cache(disk_offset);
    if (!r) {
        return 0u8;
    }
    ((u16*)cache_block)[entry_offset] = value;
    r = flush_cache();
    if (!r) {
        return 0u8;
    }
    disk_offset = fat_info.fat1_offset;
    disk_offset += (u32)sector_index;
    r = cache(disk_offset);
    if (!r) {
        return 0u8;
    }
    ((u16*)cache_block)[entry_offset] = value;
    r = flush_cache();
    return !r;
}

// returns 0xffff on error
u16 alloc_cluster(u16 last) {
    u8 r;
    u16 result = 0u16;
    u32 block_addr = fat_info.fat0_offset;
    for (u16 fat_sector = 0u16; fat_sector != fat_info.sectors_per_fat; fat_sector += 1u16) {
        r = cache(block_addr);
        if (!r) {
            return 0xffffu16;
        }
        for (u16 i = 0u16; i < (CARD_BLOCK_SIZE >> 1u16); i += 1u16) {
            u16 entry = ((u16*)cache_block)[i];
            if (entry == 0u16) {
                result += i;
                // write fat0
                ((u16*)cache_block)[i] = 0xffffu16;
                r = flush_cache();
                if (!r) {
                    return 0xffffu16;
                }
                // write fat1
                r = cache(block_addr + fat_info.fat1_offset - fat_info.fat0_offset);
                if (!r) {
                    return 0xffffu16;
                }
                ((u16*)cache_block)[i] = 0xffffu16;
                r = flush_cache();
                if (!r) {
                    return 0xffffu16;
                }

                // now write its parent, start with fat1
                block_addr = fat_info.fat1_offset + (u32)(last >> 8u8);
                r = cache(block_addr);
                if (!r) {
                    return 0xffffu16;
                }
                ((u16*)cache_block)[(u8)last] = result;
                r = flush_cache();
                if (!r) {
                    return 0xffffu16;
                }
                r = cache(block_addr + fat_info.fat0_offset - fat_info.fat1_offset);
                if (!r) {
                    return 0xffffu16;
                }
                ((u16*)cache_block)[(u8)last] = result;
                r = flush_cache();
                if (!r) {
                    return 0xffffu16;
                }
                return result;
            }
        }
        block_addr += 1u32;
        result += CARD_BLOCK_SIZE >> 1u16;
    }
    return 0xffffu16;
}

import u8 print_u32(u8 col, u8 row, u32 v);

export u8 fat_open_file(struct FatDirEntry *dir, u8 *name) {
    for (u8 fd = 0u8; fd != MAX_FILE_DESC; fd += 1u8) {
        if (file_desc[fd].is_free) {
            break;
        }
    }
    if (fd == MAX_FILE_DESC) {
        fat_last_error = FAT_ERROR_TOO_MANY_OPEN_FILES;
        return FAT_BAD_DESC;
    }

    struct FileDescriptor *pfd = (struct FileDescriptor *)file_desc + fd;
    pfd->is_free = 0u8;
    u8 r = find_file(dir, name, pfd);
    if (!r) {
        pfd->is_free = 1u8;
        return FAT_BAD_DESC;
    }

    r = init_fd(pfd);
    if (!r) {
        pfd->is_free = 1u8;
        return FAT_BAD_DESC;
    }
    return fd;
}

// returns bool
u8 init_fd(struct FileDescriptor *pfd) {
    pfd->is_root = 0u8;
    u16 cluster_mask = ~(0xffffu16 << (fat_info.log_sectors_per_cluster + 9u8));
    pfd->last_cluster_len = (u16)pfd->dir_entry.size & cluster_mask;

    pfd->dir_entry_modified = 0u8;
    return seek_begin(pfd);
}

u8 init_root_dir(struct FileDescriptor *pfd) {
    pfd->is_root = 1u8;
    pfd->block_addr = fat_info.root_dir_block;
    pfd->block_in_cluster = 0u8;
    pfd->index_in_block = 0u16;
    pfd->abs_offset = 0u32;
    pfd->dir_entry_modified = 0u8;
}

export u16 fat_read(u8 fd, u8 *dst, u16 len) {
    return fat_action(fd, dst, len, 0u8);
}

// returns bool
u8 seek_advance(struct FileDescriptor *pfd, u16 advance) {
    pfd->index_in_block += advance;
    pfd->abs_offset += (u32)advance;
    if (pfd->index_in_block == CARD_BLOCK_SIZE) {
        pfd->block_in_cluster += 1u8;
        pfd->index_in_block = 0u16;
        if (pfd->block_in_cluster == fat_info.sectors_per_cluster) {
            // next cluster
            if (pfd->is_root) {
                pfd->block_addr += 1u32;
            } else {
                pfd->block_addr = fat_info.data_offset;
                pfd->block_addr += (u32)(pfd->next_cluster - 2u16) << fat_info.log_sectors_per_cluster;
                pfd->cur_cluster = pfd->next_cluster;
                pfd->next_cluster = read_fat_entry(pfd->cur_cluster);
                if (pfd->next_cluster == 0u16) {
                    return 0u8;
                }
                pfd->block_in_cluster = 0u8;
            }
        } else {
            // next block in cluster
            pfd->block_addr += 1u32;
        }
    }
    return 1u8;
}

// returns bool
u8 seek_begin(struct FileDescriptor *pfd) {
    pfd->block_addr = fat_info.data_offset;
    pfd->block_addr += (u32)(pfd->dir_entry.cluster_lo - 2u16) << fat_info.log_sectors_per_cluster;
    pfd->block_in_cluster = 0u8;
    pfd->index_in_block = 0u16;
    pfd->next_cluster = read_fat_entry(pfd->dir_entry.cluster_lo);
    pfd->cur_cluster = pfd->dir_entry.cluster_lo;
    pfd->abs_offset = 0u32;
    return pfd->next_cluster != 0u16;
}

export u16 fat_write(u8 fd, u8 *src, u16 len) {
    return fat_action(fd, src, len, 1u8);
}

// return number of bytes processed
u16 fat_action(u8 fd, u8 *data, u16 len, u8 is_write) {
    struct FileDescriptor *pfd = (struct FileDescriptor *)file_desc + fd;
    if (pfd->is_free) {
        fat_last_error = FAT_BAD_DESC;
        return 0u16;
    }
    u16 result = 0u16;
    u8 r;
    while (len != 0u16) {
        u16 chunk_len = CARD_BLOCK_SIZE - pfd->index_in_block;
        if (pfd->next_cluster >= FAT_MIN_LAST_CLUSTER) {
            // last cluster
            u16 remainder = pfd->last_cluster_len - ((u16)pfd->block_in_cluster << 9u8);
            if (remainder <= CARD_BLOCK_SIZE) {
                // last block
                chunk_len = remainder - pfd->index_in_block;
                if (is_write) {
                    if (len > chunk_len) {
                        // expanding the file past the current size
                        chunk_len = len;
                        if (chunk_len + pfd->index_in_block > CARD_BLOCK_SIZE) {
                            // need to expand over current block
                            chunk_len = CARD_BLOCK_SIZE - pfd->index_in_block;
                        }
                        u16 delta_size = pfd->index_in_block + chunk_len - remainder;
                        pfd->last_cluster_len += delta_size;
                        pfd->dir_entry.size += (u32)delta_size;
                        pfd->dir_entry_modified = 1u8;
                        if (pfd->last_cluster_len == (CARD_BLOCK_SIZE << fat_info.log_sectors_per_cluster)) {
                            // need next block
                            u16 new_cluster = alloc_cluster(pfd->cur_cluster);
                            if (new_cluster == 0xffffu16) {
                                return result;
                            }
                            pfd->next_cluster = new_cluster;
                            pfd->last_cluster_len = 0u16;
                        }
                    }
                }
            }
        }
        if (chunk_len > len) {
            chunk_len = len;
        }
        if (chunk_len == 0u16) {
            if (pfd->abs_offset == pfd->dir_entry.size) {
                fat_last_error = FAT_EOF;
            }
            return result;
        }
        r = cache(pfd->block_addr);
        if (!r) {
            return result;
        }
        if (is_write) {
            memcpy((u8*)cache_block + pfd->index_in_block, data, chunk_len);
            r = flush_cache();
            if (!r) {
                return result;
            }
        } else {
            memcpy(data, (u8*)cache_block + pfd->index_in_block, chunk_len);
        }
        r = seek_advance(pfd, chunk_len);
        if (!r) {
            return result;
        }
        len -= chunk_len;
        data += chunk_len;
        result += chunk_len;
    }
    return result;
}


export u8 fat_close(u8 fd) {
    struct FileDescriptor *pfd = (struct FileDescriptor*)file_desc + fd;
    if (pfd->dir_entry_modified) {
        cache(pfd->dir_entry_block_addr);
        memcpy((u8*)cache_block + pfd->dir_entry_index_in_block, (u8*)&pfd->dir_entry, sizeof(struct FatDirEntry));
        flush_cache();
    }
    pfd->is_free = 1u8;
}

export u8 fat_truncate(u8 fd) {
    u8 r;
    struct FileDescriptor *pfd = (struct FileDescriptor *)file_desc + fd;
    if (pfd->is_free) {
        fat_last_error = FAT_BAD_DESC;
        return 0u8;
    }
    if (pfd->abs_offset == pfd->dir_entry.size) {
        return 1u8;
    }
    pfd->dir_entry.size = pfd->abs_offset;
    pfd->dir_entry_modified = 1u8;
    if (pfd->next_cluster < FAT_MIN_LAST_CLUSTER) {
        // there is a chain of clusters to free
        u16 cur_cluster = pfd->cur_cluster;
        u16 next_cluster = pfd->next_cluster;
        write_fat_entry(cur_cluster, 0xffffu16);
        while (next_cluster < FAT_MIN_LAST_CLUSTER) {
            cur_cluster = next_cluster;
            next_cluster = read_fat_entry(cur_cluster);
            if (next_cluster == 0u16) {
                return 0u8;
            }
            r = write_fat_entry(cur_cluster, 0u16);
            if (!r) {
                return 0u8;
            }
        }
        pfd->next_cluster = 0xffffu16;
    }
    u16 cluster_mask = ~(0xffffu16 << (fat_info.log_sectors_per_cluster + 9u8));
    pfd->last_cluster_len = (u16)pfd->abs_offset & cluster_mask;
    return 1u8;
}

export u8 fat_seek_end(u8 fd) {
    struct FileDescriptor *pfd = (struct FileDescriptor *)file_desc + fd;
    if (pfd->is_free) {
        fat_last_error = FAT_BAD_DESC;
        return 0u8;
    }

    while (pfd->next_cluster < FAT_MIN_LAST_CLUSTER) {
        pfd->cur_cluster = pfd->next_cluster;
        pfd->next_cluster = read_fat_entry(pfd->next_cluster);
        if (pfd->next_cluster == 0u16) {
            return 0u8;
        }
    }
    pfd->abs_offset = pfd->dir_entry.size;
    pfd->block_in_cluster = (u8)(pfd->last_cluster_len >> 9u8);
    pfd->index_in_block = pfd->last_cluster_len & (CARD_BLOCK_SIZE - 1u16);
    pfd->block_addr = fat_info.data_offset + ((u32)(pfd->cur_cluster - 2u16) << fat_info.log_sectors_per_cluster) + (u32)pfd->block_in_cluster;
    return 1u8;
}
